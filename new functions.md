Workflow Overview:
1.	Frontend (React):
1.	Login 
2.	Company setup (seller):  Name, logo, ntn, province city address
3.	Item management
4.	Invoice creation mechanism 
invoiceDate	Invoice Creation Page → Auto-filled to current date, editable
sellerNTNCNIC	Settings Page → Stored in your app config / FBR account setup
sellerBusinessName	Settings Page → Managed once as your seller profile
sellerProvince	Settings Page → Static; managed with seller profile
sellerAddress	Settings Page → Static; managed with seller profile
buyerNTNCNIC	Customer Management Page → Part of customer profile
buyerBusinessName	Customer Management Page → Part of customer profile
buyerProvince	Customer Management Page → Part of customer profile
buyerAddress	Customer Management Page → Part of customer profile
buyerRegistrationType	Customer Management Page → Dropdown: Registered / Unregistered
invoiceRefNo	Invoice Creation Page → Auto-generated by backend bit editable
scenarioId	Only for testing/sandbox will be not used in production
items	Invoice Creation Page → Line items table (Add Item rows)
________________________________________
 UI Table on Invoice Creation Page
Field	Where It's Set in UI
hsCode	Auto-filled from Item Management Page (when item is selected)
productDescription	Auto-filled or editable when selecting item
rate (Tax Rate)	Auto-filled from item, or editable per row
uoM	Auto-filled from item details
quantity	Entered by user per row
Total Sales Value (Including Tax)	Auto-calculated: value + Tax/es
valueSalesExcludingST	Auto-calculated: quantity × unit price
fixedNotifiedValueOrRetailPrice	Optional input; managed from Item Management[value-(per unit)]
salesTaxApplicable	Auto-calculated: tax amount
salesTaxWithheldAtSource	Optional input; managed from Item Management(value in %)
extraTax	Optional input; managed from Item Management(value in %)
furtherTax	Optional input; managed from Item Management(value in %)

sroItemSerialNo	Optional input; managed from Item Management(value)
fedPayable	Optional input; managed from Item Management(value in %)
discount	Optional input (per line item)
saleType	Goods at standard rate (default)/exempt
sroScheduleNo
	Optional input; managed from Item Management(value)



________________________________________ Summary: UI Management Table
Page	Fields Managed
Settings Page	sellerNTNCNIC, sellerBusinessName, sellerProvince, sellerAddress
Customer Management Page	buyerNTNCNIC, buyerBusinessName, buyerProvince, buyerAddress, buyerRegistrationType
Item Management Page	hsCode, uoM, fixedNotifiedValueOrRetailPrice, Per unit price, tax rate, furthertax, fixedNotifiedValueOrRetailPrice, salesTaxWithheldAtSource, extraTax, sroScheduleNo, sroItemSerialNo , saletype (standard/exempt)
Invoice Creation Page	invoiceDate, invoiceRefNo, quantity, taxes(auto calculate), discounts, saleType

5.	Item line add/delete/clone options
6.	Invoice pdf print: With fbr logo, qr code and fbr inv reference number
7.	clone invoice option

a.	User Interface for Invoice Management
b.	Customer Management name, business name, NTN/CNIC, reg/unreg province, city, address, 
c.	Invoice Data Entry	


d.	Excel Upload for Batch Invoices
e.	Display of validation errors and success notifications
8.	Backend (FastAPI):
a.	Invoicing API (CRUD operations: Create, Read, Update, Delete)
b.	Customer Management API
c.	FBR API Integration (Post and Validate)
d.	Excel Parsing for Batch Upload
9.	Database (PostgreSQL):
a.	Tables for Invoices and Customers
b.	Validations and relationships between invoices and customers
10.	FBR Integration:
a.	Post Invoices to FBR Sandbox/Production APIs
b.	Validate Invoices via FBR API
c.	Token Management (even though N/A for now)
________________________________________
Detailed Workflow:
1. Customer Management
•	Create/Update/Delete/View Customers:
o	Frontend allows adding, updating, and deleting customer details (name, address, tax number, etc.).
o	The data is sent via API to the FastAPI backend, where it’s validated and stored in the PostgreSQL database.
2. Invoice Creation & Management
•	Invoice Creation:
o	A user can create a new invoice from the frontend.
o	The user will input invoice details such as customer selection, products, tax rates, and so on.
o	The backend receives the invoice data, validates it (check for required fields), and stores the invoice in the PostgreSQL database.
•	Invoice Edit/Update:
o	If the invoice is not finalized, the user can edit the invoice (add/remove items, update customer info, etc.).
o	Updated data is sent to FastAPI backend, validated, and stored in PostgreSQL.
•	Invoice Deletion:
o	User can delete invoices before finalization.
o	Invoices are deleted from PostgreSQL using FastAPI.
3. Batch Invoice Upload via Excel
•	Frontend:
o	A file input field for uploading Excel files (typically in .xlsx format).
o	The frontend sends the file to the FastAPI backend.
•	Backend:
o	FastAPI receives the file and uses a library like openpyxl or pandas to parse the Excel file.
o	Each row of the Excel sheet is parsed as an individual invoice.
o	The system should validate each invoice’s data and then save them to the PostgreSQL database.
•	Post Validation (Optional but Recommended):
o	After saving, the system can optionally validate the invoices via the FBR API. If validation fails, the user is notified, and invalid records are flagged for review.
4. Posting Invoices to FBR (FBR API Integration)
•	Invoice Finalization:
o	Once an invoice is ready and validated, it can be finalized. The user triggers an "Upload to FBR" button.
•	Backend Logic:
o	FastAPI prepares the JSON payload to match FBR’s acceptable format using the invoice details (following the JSON structure provided).
o	The system will send a POST request to the FBR's Post Invoice API endpoint using the appropriate API URL based on whether the system is in Sandbox or Production mode.
o	If posting is successful, the system should update the invoice status to "Posted" or "Completed" in the database.
•	FBR Response Handling:
o	The system should handle the response from FBR (success or error) and display the result to the user.
o	If the response contains errors (e.g., validation issues), those errors should be shown on the frontend for the user to correct.
5. FBR Invoice Validation
•	Invoice Validation Process:
o	Before posting to FBR, you can optionally validate the invoice via the Validate Invoice API endpoint.
o	FastAPI will send the same JSON payload to the FBR validation endpoint, and the system will await the response.
o	If the response indicates any issues (e.g., missing fields or incorrect data), the system will notify the user to correct the issues before proceeding to post the invoice.
6. Token Handling (For future use)
•	Modular Token Management:
o	Although the token is not currently required for the sandbox, it’s good to implement a modular system that will support token authentication in the future when it’s introduced.
o	Tokens can be stored and managed separately in the backend, and requests to the FBR API can include the token if needed.
•	FastAPI will be responsible for:
o	Storing and retrieving tokens.
o	Refreshing tokens (if the FBR API supports token expiration).
o	Using the token in API requests to FBR (once tokens are needed).
________________________________________
FBR JSON Format Mapping
Here’s a mapping of your invoice data structure to the JSON payload required by FBR:
1.	Invoice Data:
o	invoiceType: Can be "Sale Invoice" or "Purchase Invoice".
o	invoiceDate: Date format yyyy-MM-dd.
o	sellerNTNCNIC: Seller’s National Tax Number or NIC.
o	sellerBusinessName: Seller's business name.
o	sellerProvince: Seller's province.
o	sellerAddress: Seller's full address.
o	buyerNTNCNIC: Buyer’s National Tax Number or NIC.
o	buyerBusinessName: Buyer’s business name.
o	buyerProvince: Buyer’s province.
o	buyerAddress: Buyer’s full address.
o	buyerRegistrationType: Typically “Registered”.
2.	Invoice Items:
o	Each item in the invoice (product) has the following:
	hsCode: The Harmonized Code for the item.
	productDescription: A description of the product.
	rate: Tax rate applicable (e.g., "0%" for no tax).
	uoM: Unit of Measure (e.g., "kg", "unit").
	quantity: Quantity of the item sold.
	totalValues: Total value for this item.
	valueSalesExcludingST: Value excluding sales tax.
	salesTaxApplicable: Amount of sales tax for the item.
	salesTaxWithheldAtSource: Amount of sales tax withheld at source.
	sroScheduleNo: Schedule number for the item (if applicable).
	Additional optional fields for extra taxes, discounts, and sale type.
________________________________________
Final Flow Diagram (Conceptual)
rust
CopyEdit
Frontend (React)  <-->  Backend (FastAPI)  <-->  PostgreSQL DB
         |                      |                     |
   Customer Management     Invoice Management      Invoices & Customers
         |                      |
   Excel Upload <--> Invoice CRUD (POST/PUT/DELETE)
         |                      |
    Finalize Invoice <--> FBR Integration (POST/VALIDATE)
         |
    FBR Response <--> Notify User (Success/Error)
________________________________________
Tools and Libraries
•	Frontend (React):
o	React for UI, Axios for HTTP requests.
o	Libraries like xlsx or react-dropzone for handling Excel uploads.
•	Backend (FastAPI):
o	FastAPI for building RESTful APIs.
o	Pydantic for request validation.
o	openpyxl or pandas for Excel file parsing.
o	httpx for async HTTP requests (e.g., FBR API).
•	Database (PostgreSQL):
o	PostgreSQL to store invoices and customer data.
o	SQLAlchemy or Tortoise ORM for ORM-based queries.

________________________________________
# DETAILED IMPLEMENTATION PLAN

## Current State Analysis
- ✅ Basic FastAPI backend with user authentication
- ✅ Simple React frontend with Chakra UI
- ✅ PostgreSQL database with UUID-based models
- ✅ Basic invoice PDF generation
- ❌ Missing: FBR-specific models, customer management, item management, FBR API integration

## Step-by-Step Implementation Plan

### Phase 1: Database Schema & Models (Week 1)

#### 1.1 Create Company/Seller Model
```python
class Company(SQLModel, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    business_name: str = Field(max_length=255)
    ntn_cnic: str = Field(max_length=50)
    province: str = Field(max_length=100)
    city: str = Field(max_length=100)
    address: str = Field(max_length=500)
    logo_url: str | None = Field(default=None, max_length=255)
    owner_id: uuid.UUID = Field(foreign_key="user.id", nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

#### 1.2 Create Customer Model
```python
class Customer(SQLModel, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    business_name: str = Field(max_length=255)
    ntn_cnic: str = Field(max_length=50)
    province: str = Field(max_length=100)
    city: str = Field(max_length=100)
    address: str = Field(max_length=500)
    registration_type: str = Field(max_length=20)  # "Registered" or "Unregistered"
    owner_id: uuid.UUID = Field(foreign_key="user.id", nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

#### 1.3 Create Product Model
```python
class Product(SQLModel, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    hs_code: str = Field(max_length=20)
    description: str = Field(max_length=500)
    uom: str = Field(max_length=20)  # Unit of Measure
    unit_price: float = Field(ge=0)
    tax_rate: float = Field(ge=0, le=100)  # Percentage
    fixed_notified_value: float | None = Field(default=None, ge=0)
    sales_tax_withheld_rate: float | None = Field(default=None, ge=0, le=100)
    extra_tax_rate: float | None = Field(default=None, ge=0, le=100)
    further_tax_rate: float | None = Field(default=None, ge=0, le=100)
    fed_payable_rate: float | None = Field(default=None, ge=0, le=100)
    sro_schedule_no: str | None = Field(default=None, max_length=50)
    sro_item_serial_no: str | None = Field(default=None, max_length=50)
    sale_type: str = Field(default="standard", max_length=20)  # "standard" or "exempt"
    owner_id: uuid.UUID = Field(foreign_key="user.id", nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

#### 1.4 Create FBR Invoice Model
```python
class FBRInvoice(SQLModel, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    invoice_ref_no: str = Field(max_length=50, unique=True)
    invoice_date: date = Field(default_factory=date.today)
    invoice_type: str = Field(default="Sale Invoice", max_length=50)
    scenario_id: str | None = Field(default=None, max_length=50)  # For testing
    
    # Seller Information
    seller_ntn_cnic: str = Field(max_length=50)
    seller_business_name: str = Field(max_length=255)
    seller_province: str = Field(max_length=100)
    seller_address: str = Field(max_length=500)
    
    # Buyer Information
    buyer_ntn_cnic: str = Field(max_length=50)
    buyer_business_name: str = Field(max_length=255)
    buyer_province: str = Field(max_length=100)
    buyer_address: str = Field(max_length=500)
    buyer_registration_type: str = Field(max_length=20)
    
    # Totals
    total_sales_value: float = Field(ge=0)
    total_tax_amount: float = Field(ge=0)
    total_invoice_value: float = Field(ge=0)
    
    # Status and FBR Integration
    status: str = Field(default="draft", max_length=20)  # draft, submitted, posted, error
    fbr_reference: str | None = Field(default=None, max_length=100)
    fbr_response: str | None = Field(default=None)  # JSON response from FBR
    
    # Relationships
    customer_id: uuid.UUID = Field(foreign_key="customer.id", nullable=False)
    company_id: uuid.UUID = Field(foreign_key="company.id", nullable=False)
    owner_id: uuid.UUID = Field(foreign_key="user.id", nullable=False)
    
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

#### 1.5 Create Invoice Item Model
```python
class FBRInvoiceItem(SQLModel, table=True):
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    invoice_id: uuid.UUID = Field(foreign_key="fbrinvoice.id", nullable=False)
    product_id: uuid.UUID = Field(foreign_key="product.id", nullable=False)
    
    # Item Details
    hs_code: str = Field(max_length=20)
    product_description: str = Field(max_length=500)
    uom: str = Field(max_length=20)
    quantity: float = Field(gt=0)
    unit_price: float = Field(ge=0)
    
    # Tax Calculations
    value_sales_excluding_st: float = Field(ge=0)
    sales_tax_applicable: float = Field(ge=0)
    sales_tax_withheld_at_source: float | None = Field(default=None, ge=0)
    extra_tax: float | None = Field(default=None, ge=0)
    further_tax: float | None = Field(default=None, ge=0)
    fed_payable: float | None = Field(default=None, ge=0)
    
    # Additional Fields
    fixed_notified_value: float | None = Field(default=None, ge=0)
    discount: float | None = Field(default=None, ge=0)
    sro_schedule_no: str | None = Field(default=None, max_length=50)
    sro_item_serial_no: str | None = Field(default=None, max_length=50)
    sale_type: str = Field(default="standard", max_length=20)
    
    # Calculated Total
    total_value: float = Field(ge=0)
    
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

#### 1.6 Create Alembic Migration
- Create migration file for all new tables
- Add proper indexes and constraints
- Set up foreign key relationships

### Phase 2: Backend API Development (Week 2-3)

#### 2.1 Company/Settings Management API
**File: `backend/app/api/routes/company.py`**
```python
@router.post("/", response_model=CompanyPublic)
async def create_company(company: CompanyCreate, session: Session, current_user: User):
    # Create company profile for current user

@router.get("/me", response_model=CompanyPublic)
async def get_my_company(session: Session, current_user: User):
    # Get current user's company profile

@router.put("/me", response_model=CompanyPublic)
async def update_my_company(company: CompanyUpdate, session: Session, current_user: User):
    # Update current user's company profile
```

#### 2.2 Customer Management API
**File: `backend/app/api/routes/customers.py`**
```python
@router.post("/", response_model=CustomerPublic)
async def create_customer(customer: CustomerCreate, session: Session, current_user: User):

@router.get("/", response_model=CustomersPublic)
async def read_customers(session: Session, current_user: User, skip: int = 0, limit: int = 100):

@router.get("/{customer_id}", response_model=CustomerPublic)
async def read_customer(customer_id: uuid.UUID, session: Session, current_user: User):

@router.put("/{customer_id}", response_model=CustomerPublic)
async def update_customer(customer_id: uuid.UUID, customer: CustomerUpdate, session: Session, current_user: User):

@router.delete("/{customer_id}")
async def delete_customer(customer_id: uuid.UUID, session: Session, current_user: User):
```

#### 2.3 Product Management API
**File: `backend/app/api/routes/products.py`**
```python
@router.post("/", response_model=ProductPublic)
async def create_product(product: ProductCreate, session: Session, current_user: User):

@router.get("/", response_model=ProductsPublic)
async def read_products(session: Session, current_user: User, skip: int = 0, limit: int = 100):

@router.get("/{product_id}", response_model=ProductPublic)
async def read_product(product_id: uuid.UUID, session: Session, current_user: User):

@router.put("/{product_id}", response_model=ProductPublic)
async def update_product(product_id: uuid.UUID, product: ProductUpdate, session: Session, current_user: User):

@router.delete("/{product_id}")
async def delete_product(product_id: uuid.UUID, session: Session, current_user: User):
```

#### 2.4 Enhanced Invoice API
**File: `backend/app/api/routes/fbr_invoices.py`**
```python
@router.post("/", response_model=FBRInvoicePublic)
async def create_fbr_invoice(invoice: FBRInvoiceCreate, session: Session, current_user: User):
    # Create FBR-compliant invoice with auto-calculations

@router.get("/", response_model=FBRInvoicesPublic)
async def read_fbr_invoices(session: Session, current_user: User, skip: int = 0, limit: int = 100):

@router.get("/{invoice_id}", response_model=FBRInvoicePublic)
async def read_fbr_invoice(invoice_id: uuid.UUID, session: Session, current_user: User):

@router.put("/{invoice_id}", response_model=FBRInvoicePublic)
async def update_fbr_invoice(invoice_id: uuid.UUID, invoice: FBRInvoiceUpdate, session: Session, current_user: User):
    # Only allow updates if status is "draft"

@router.post("/{invoice_id}/clone", response_model=FBRInvoicePublic)
async def clone_fbr_invoice(invoice_id: uuid.UUID, session: Session, current_user: User):

@router.post("/{invoice_id}/submit-to-fbr")
async def submit_to_fbr(invoice_id: uuid.UUID, session: Session, current_user: User):
    # Submit invoice to FBR API

@router.get("/{invoice_id}/pdf")
async def generate_fbr_invoice_pdf(invoice_id: uuid.UUID, session: Session, current_user: User):
    # Generate FBR-compliant PDF with QR code
```

#### 2.5 FBR Integration Service
**File: `backend/app/services/fbr_integration.py`**
```python
class FBRService:
    def __init__(self, sandbox: bool = True):
        self.base_url = "https://sandbox.fbr.gov.pk" if sandbox else "https://api.fbr.gov.pk"
        self.client = httpx.AsyncClient()
    
    async def post_invoice(self, invoice_data: dict) -> dict:
        # Post invoice to FBR API
    
    async def validate_invoice(self, invoice_data: dict) -> dict:
        # Validate invoice via FBR API
    
    def format_invoice_for_fbr(self, invoice: FBRInvoice, items: List[FBRInvoiceItem]) -> dict:
        # Convert internal models to FBR JSON format
```

#### 2.6 Excel Upload Service
**File: `backend/app/services/excel_processor.py`**
```python
class ExcelInvoiceProcessor:
    def __init__(self, session: Session, current_user: User):
        self.session = session
        self.current_user = current_user
    
    async def process_excel_file(self, file_content: bytes) -> dict:
        # Parse Excel file and create invoices
        # Return success/error report
    
    def validate_excel_row(self, row_data: dict) -> List[str]:
        # Validate individual row data
        # Return list of validation errors
```

### Phase 3: Frontend Development (Week 4-5)

#### 3.1 Settings/Company Setup Page
**File: `frontend/src/routes/_layout/settings/company.tsx`**
- Company information form
- Logo upload component
- Province/city selection
- Address management

#### 3.2 Customer Management Interface
**File: `frontend/src/routes/_layout/customers/`**
- `index.tsx` - Customer list with search/filter
- `create.tsx` - Add new customer form
- `$customerId/edit.tsx` - Edit customer form
- Components: CustomerTable, CustomerForm, CustomerSearch

#### 3.3 Product Management Interface
**File: `frontend/src/routes/_layout/products/`**
- `index.tsx` - Product catalog
- `create.tsx` - Add new product form
- `$productId/edit.tsx` - Edit product form
- Components: ProductTable, ProductForm, TaxConfiguration

#### 3.4 Enhanced Invoice Creation Page
**File: `frontend/src/routes/_layout/invoices/`**
- `create.tsx` - New invoice creation
- `$invoiceId/edit.tsx` - Edit existing invoice
- `$invoiceId/view.tsx` - View invoice details
- Components: InvoiceForm, LineItemTable, CustomerSelector, ProductSelector

#### 3.5 Invoice Management Dashboard
**File: `frontend/src/routes/_layout/invoices/index.tsx`**
- Invoice list with status indicators
- Filter by date, customer, status
- Actions: View, Edit, Clone, Submit to FBR, Download PDF

#### 3.6 Excel Upload Interface
**File: `frontend/src/routes/_layout/invoices/upload.tsx`**
- File upload component with drag-and-drop
- Progress tracking
- Error display and validation results
- Template download

### Phase 4: FBR Integration & PDF Enhancement (Week 6)

#### 4.1 FBR API Integration
- Implement sandbox testing
- Error handling and user feedback
- Status tracking and updates

#### 4.2 Enhanced PDF Generation
**File: `backend/app/services/fbr_pdf_generator.py`**
- Include FBR logo and QR code
- Professional invoice layout
- Tax breakdown display
- FBR reference number

#### 4.3 Invoice Status Management
- Implement state machine for invoice status
- Prevent editing after FBR submission
- Status indicators in UI

### Phase 5: Testing & Deployment (Week 7)

#### 5.1 Unit Testing
- API endpoint tests
- Database model tests
- FBR integration tests
- PDF generation tests

#### 5.2 Integration Testing
- End-to-end invoice workflow
- Excel upload functionality
- FBR submission testing

#### 5.3 User Acceptance Testing
- Complete invoice creation workflow
- FBR submission in sandbox
- Error handling validation

## Implementation Checklist

### Database & Models
- [ ] Create Company model and migration
- [ ] Create Customer model and migration
- [ ] Create Product model and migration
- [ ] Create FBRInvoice model and migration
- [ ] Create FBRInvoiceItem model and migration
- [ ] Add proper indexes and constraints
- [ ] Test all relationships

### Backend APIs
- [ ] Company management endpoints
- [ ] Customer CRUD endpoints
- [ ] Product CRUD endpoints
- [ ] FBR Invoice CRUD endpoints
- [ ] FBR integration service
- [ ] Excel upload processor
- [ ] Enhanced PDF generator
- [ ] Invoice validation logic
- [ ] Tax calculation engine

### Frontend Components
- [ ] Company settings page
- [ ] Customer management interface
- [ ] Product management interface
- [ ] Enhanced invoice creation
- [ ] Invoice dashboard
- [ ] Excel upload interface
- [ ] Status indicators
- [ ] Error handling

### FBR Integration
- [ ] Sandbox API integration
- [ ] Invoice posting
- [ ] Invoice validation
- [ ] Error handling
- [ ] Status tracking
- [ ] Response processing

### Testing
- [ ] Unit tests for all models
- [ ] API endpoint tests
- [ ] FBR integration tests
- [ ] Frontend component tests
- [ ] End-to-end workflow tests
- [ ] Excel upload tests
- [ ] PDF generation tests

### Documentation
- [ ] API documentation
- [ ] User manual
- [ ] FBR integration guide
- [ ] Excel template documentation
- [ ] Deployment guide

This plan provides a comprehensive roadmap for implementing all FBR invoicing requirements while maintaining the existing system structure.

